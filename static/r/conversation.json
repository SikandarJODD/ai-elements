{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "conversation",
	"type": "registry:block",
	"description": "The Conversation component provides a structured layout for displaying a series of chat messages between a user and an AI. It supports features like message grouping, typing indicators, and customizable avatars.",
	"dependencies": [
		"runed@^0.31.1"
	],
	"devDependencies": [
		"@lucide/svelte@^0.544.0"
	],
	"registryDependencies": [
		"button"
	],
	"meta": {
		"author": "SikandarJODD"
	},
	"files": [
		{
			"content": "<script lang=\"ts\" module>\r\n  import { cn, type WithElementRef } from \"$UTILS$/utils.js\";\r\n  import type { HTMLAttributes } from \"svelte/elements\";\r\n  import type { Snippet } from \"svelte\";\r\n\r\n  export interface ConversationProps\r\n    extends WithElementRef<HTMLAttributes<HTMLDivElement>> {\r\n    children?: Snippet;\r\n    initial?: ScrollBehavior;\r\n    resize?: ScrollBehavior;\r\n  }\r\n</script>\r\n\r\n<script lang=\"ts\">\r\n  import { setStickToBottomContext } from \"./stick-to-bottom-context.svelte.js\";\r\n\r\n  let {\r\n    class: className,\r\n    children,\r\n    initial = \"smooth\",\r\n    resize = \"smooth\",\r\n    ref = $bindable(null),\r\n    ...restProps\r\n  }: ConversationProps = $props();\r\n\r\n  let context = setStickToBottomContext();\r\n</script>\r\n\r\n<div\r\n  bind:this={ref}\r\n  class={cn(\"relative flex flex-col h-full overflow-hidden\", className)}\r\n  role=\"log\"\r\n  {...restProps}\r\n>\r\n  {@render children?.()}\r\n</div>\r\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/Conversation.svelte"
		},
		{
			"content": "<script lang=\"ts\" module>\r\n  import { cn, type WithElementRef } from \"$UTILS$/utils.js\";\r\n  import type { HTMLAttributes } from \"svelte/elements\";\r\n  import type { Snippet } from \"svelte\";\r\n\r\n  export interface ConversationContentProps\r\n    extends WithElementRef<HTMLAttributes<HTMLDivElement>> {\r\n    children?: Snippet;\r\n  }\r\n</script>\r\n\r\n<script lang=\"ts\">\r\n  import { getStickToBottomContext } from \"./stick-to-bottom-context.svelte.js\";\r\n  import { watch } from \"runed\";\r\n\r\n  let {\r\n    class: className,\r\n    children,\r\n    ref = $bindable(null),\r\n    ...restProps\r\n  }: ConversationContentProps = $props();\r\n\r\n  const context = getStickToBottomContext();\r\n  let element: HTMLDivElement;\r\n\r\n  watch(\r\n    () => element,\r\n    () => {\r\n      if (element) {\r\n        context.setElement(element);\r\n        // Initial scroll to bottom\r\n        context.scrollToBottom(\"smooth\");\r\n      }\r\n    }\r\n  );\r\n</script>\r\n\r\n<div\r\n  bind:this={element}\r\n  bind:this={ref}\r\n  class={cn(\"flex-1 overflow-y-auto p-4\", className)}\r\n  {...restProps}\r\n>\r\n  {@render children?.()}\r\n</div>\r\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/ConversationContent.svelte"
		},
		{
			"content": "<script lang=\"ts\" module>\r\n\timport { cn, type WithElementRef } from \"$UTILS$/utils.js\";\r\n\timport type { HTMLAttributes } from \"svelte/elements\";\r\n\timport type { Snippet } from \"svelte\";\r\n\r\n\texport interface ConversationEmptyStateProps extends WithElementRef<HTMLAttributes<HTMLDivElement>> {\r\n\t\ttitle?: string;\r\n\t\tdescription?: string;\r\n\t\ticon?: Snippet;\r\n\t\tchildren?: Snippet;\r\n\t}\r\n</script>\r\n\r\n<script lang=\"ts\">\r\n\tlet {\r\n\t\tclass: className,\r\n\t\ttitle = \"No messages yet\",\r\n\t\tdescription = \"Start a conversation to see messages here\",\r\n\t\ticon,\r\n\t\tchildren,\r\n\t\tref = $bindable(null),\r\n\t\t...restProps\r\n\t}: ConversationEmptyStateProps = $props();\r\n</script>\r\n\r\n<div\r\n\tbind:this={ref}\r\n\tclass={cn(\r\n\t\t\"flex size-full flex-col items-center justify-center gap-3 p-8 text-center\",\r\n\t\tclassName\r\n\t)}\r\n\t{...restProps}\r\n>\r\n\t{#if children}\r\n\t\t{@render children?.()}\r\n\t{:else}\r\n\t\t{#if icon}\r\n\t\t\t<div class=\"text-muted-foreground\">\r\n\t\t\t\t{@render icon()}\r\n\t\t\t</div>\r\n\t\t{/if}\r\n\t\t<div class=\"space-y-1\">\r\n\t\t\t<h3 class=\"font-medium text-sm\">{title}</h3>\r\n\t\t\t{#if description}\r\n\t\t\t\t<p class=\"text-muted-foreground text-sm\">{description}</p>\r\n\t\t\t{/if}\r\n\t\t</div>\r\n\t{/if}\r\n</div>",
			"type": "registry:component",
			"target": "ai-elements/conversation/ConversationEmptyState.svelte"
		},
		{
			"content": "<script lang=\"ts\" module>\r\n  import { cn } from \"$UTILS$/utils.js\";\r\n  import type { ButtonProps } from \"$lib/components/ui/button/button.svelte\";\r\n\r\n  export interface ConversationScrollButtonProps extends ButtonProps {}\r\n</script>\r\n\r\n<script lang=\"ts\">\r\n  import Button from \"$lib/components/ui/button/button.svelte\";\r\n  import { ArrowDown } from \"@lucide/svelte\";\r\n  import { getStickToBottomContext } from \"./stick-to-bottom-context.svelte.js\";\r\n  import { fade, fly, scale } from \"svelte/transition\";\r\n  import { backOut } from \"svelte/easing\";\r\n\r\n  let {\r\n    class: className,\r\n    onclick,\r\n    ...restProps\r\n  }: ConversationScrollButtonProps = $props();\r\n\r\n  const context = getStickToBottomContext();\r\n\r\n  const handleScrollToBottom = (event: MouseEvent) => {\r\n    context.scrollToBottom();\r\n    if (onclick) {\r\n      onclick(\r\n        event as MouseEvent & { currentTarget: EventTarget & HTMLButtonElement }\r\n      );\r\n    }\r\n  };\r\n</script>\r\n\r\n{#if !context.isAtBottom}\r\n  <div\r\n    in:fly={{\r\n      duration: 300,\r\n      y: 10,\r\n      easing: backOut,\r\n    }}\r\n    out:fly={{\r\n      duration: 200,\r\n      y: 10,\r\n      easing: backOut,\r\n    }}\r\n    class=\"absolute bottom-4 left-[50%] translate-x-[-50%]\"\r\n  >\r\n    <Button\r\n      class={cn(\r\n        \"rounded-full shadow-lg backdrop-blur-sm bg-background/80 border-border/50 hover:bg-background/90 hover:shadow-xl\",\r\n        className\r\n      )}\r\n      onclick={handleScrollToBottom}\r\n      size=\"icon\"\r\n      type=\"button\"\r\n      variant=\"outline\"\r\n      {...restProps}\r\n    >\r\n      <ArrowDown class=\"size-4\" />\r\n    </Button>\r\n  </div>\r\n{/if}\r\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/ConversationScrollButton.svelte"
		},
		{
			"content": "import { watch } from \"runed\";\r\nimport { setContext, getContext } from \"svelte\";\r\n\r\nconst STICK_TO_BOTTOM_CONTEXT_KEY = Symbol(\"stick-to-bottom-context\");\r\n\r\nclass StickToBottomContext {\r\n  #element: HTMLElement | null = $state(null);\r\n  #isAtBottom = $state(true);\r\n  #resizeObserver: ResizeObserver | null = null;\r\n  #mutationObserver: MutationObserver | null = null;\r\n  #intersectionObserver: IntersectionObserver | null = null;\r\n  #sentinel: HTMLElement | null = null;\r\n  #userHasScrolled = $state(false);\r\n\r\n  isAtBottom = $derived(this.#isAtBottom);\r\n\r\n  // Debug method to help troubleshoot\r\n  get debugInfo() {\r\n    if (!this.#element) return null;\r\n    const { scrollTop, scrollHeight, clientHeight } = this.#element;\r\n    return {\r\n      scrollTop,\r\n      scrollHeight,\r\n      clientHeight,\r\n      isAtBottom: this.#isAtBottom,\r\n      userHasScrolled: this.#userHasScrolled,\r\n      hasElement: !!this.#element,\r\n      hasSentinel: !!this.#sentinel\r\n    };\r\n  }\r\n\r\n  constructor() {\r\n    watch(\r\n      () => this.#element,\r\n      () => {\r\n        if (this.#element) {\r\n          this.#setupObservers();\r\n          return () => this.#cleanup();\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  setElement(element: HTMLElement) {\r\n    this.#element = element;\r\n  }\r\n\r\n  scrollToBottom = (behavior: ScrollBehavior = \"smooth\") => {\r\n    if (!this.#element) return;\r\n\r\n    this.#userHasScrolled = false; // Reset user scroll flag when programmatically scrolling\r\n    this.#element.scrollTo({\r\n      top: this.#element.scrollHeight,\r\n      behavior,\r\n    });\r\n  };\r\n\r\n  #handleScroll = () => {\r\n    if (!this.#element) return;\r\n\r\n    // Detect if user has scrolled up from bottom\r\n    const { scrollTop, scrollHeight, clientHeight } = this.#element;\r\n    const threshold = 200; // Increased threshold for better UX\r\n    const isAtBottom = scrollTop + clientHeight >= scrollHeight - threshold;\r\n\r\n    // Update the isAtBottom state based on scroll position\r\n    this.#isAtBottom = isAtBottom;\r\n\r\n    if (!isAtBottom) {\r\n      this.#userHasScrolled = true;\r\n    } else if (isAtBottom && this.#userHasScrolled) {\r\n      // User scrolled back to bottom, reset flag\r\n      this.#userHasScrolled = false;\r\n    }\r\n  };\r\n\r\n  #setupObservers() {\r\n    if (!this.#element) return;\r\n\r\n    // Create and position sentinel element\r\n    this.#createSentinel();\r\n\r\n    // Setup intersection observer to detect if we're at bottom\r\n    this.#intersectionObserver = new IntersectionObserver(\r\n      (entries) => {\r\n        const entry = entries[0];\r\n        // Use intersection observer as a backup, but prioritize scroll-based detection\r\n        if (entry.isIntersecting) {\r\n          this.#isAtBottom = true;\r\n          this.#userHasScrolled = false;\r\n        }\r\n      },\r\n      {\r\n        threshold: 0,\r\n        root: this.#element\r\n      }\r\n    );\r\n\r\n    if (this.#sentinel) {\r\n      this.#intersectionObserver.observe(this.#sentinel);\r\n    }\r\n\r\n    // Add scroll event listener to detect user scrolling\r\n    this.#element.addEventListener(\"scroll\", this.#handleScroll, {\r\n      passive: true,\r\n    });\r\n\r\n    // Setup resize observer for smooth scrolling on resize\r\n    this.#resizeObserver = new ResizeObserver(() => {\r\n      // Check position after resize\r\n      this.#checkScrollPosition();\r\n      if (this.#isAtBottom && !this.#userHasScrolled) {\r\n        this.scrollToBottom(\"auto\");\r\n      }\r\n    });\r\n\r\n    this.#resizeObserver.observe(this.#element);\r\n\r\n    // Setup mutation observer for smooth scrolling on content changes\r\n    this.#mutationObserver = new MutationObserver(() => {\r\n      // Small delay to ensure DOM has updated\r\n      requestAnimationFrame(() => {\r\n        // Check if we should auto-scroll BEFORE updating the position\r\n        // Only auto-scroll if user was at bottom and hasn't manually scrolled\r\n        const shouldAutoScroll = this.#isAtBottom && !this.#userHasScrolled;\r\n\r\n        // Now update the scroll position after content changes\r\n        this.#checkScrollPosition();\r\n\r\n        // Auto-scroll if conditions were met\r\n        if (shouldAutoScroll) {\r\n          this.scrollToBottom(\"smooth\");\r\n        }\r\n      });\r\n    });\r\n\r\n    this.#mutationObserver.observe(this.#element, {\r\n      childList: true,\r\n      subtree: true,\r\n      characterData: true,\r\n    });\r\n\r\n    // Check initial state\r\n    this.#checkScrollPosition();\r\n  }\r\n\r\n  #createSentinel() {\r\n    if (!this.#element) return;\r\n\r\n    this.#sentinel = document.createElement(\"div\");\r\n    this.#sentinel.style.height = \"1px\";\r\n    this.#sentinel.style.width = \"100%\";\r\n    this.#sentinel.style.pointerEvents = \"none\";\r\n    this.#sentinel.style.opacity = \"0\";\r\n    this.#sentinel.setAttribute(\"data-stick-to-bottom-sentinel\", \"\");\r\n\r\n    // Append to the end of the scrollable content, not positioned absolutely\r\n    this.#element.appendChild(this.#sentinel);\r\n  }\r\n\r\n  #checkScrollPosition() {\r\n    if (!this.#element) return;\r\n\r\n    const { scrollTop, scrollHeight, clientHeight } = this.#element;\r\n    const threshold = 200; // Increased threshold for better UX\r\n    const isAtBottom = scrollTop + clientHeight >= scrollHeight - threshold;\r\n\r\n    this.#isAtBottom = isAtBottom;\r\n  }\r\n\r\n  #cleanup() {\r\n    this.#resizeObserver?.disconnect();\r\n    this.#mutationObserver?.disconnect();\r\n    this.#intersectionObserver?.disconnect();\r\n\r\n    // Remove scroll event listener\r\n    if (this.#element) {\r\n      this.#element.removeEventListener(\"scroll\", this.#handleScroll);\r\n    }\r\n\r\n    if (this.#sentinel && this.#element?.contains(this.#sentinel)) {\r\n      this.#element.removeChild(this.#sentinel);\r\n    }\r\n\r\n    this.#resizeObserver = null;\r\n    this.#mutationObserver = null;\r\n    this.#intersectionObserver = null;\r\n    this.#sentinel = null;\r\n  }\r\n}\r\n\r\nexport function setStickToBottomContext(): StickToBottomContext {\r\n  const context = new StickToBottomContext();\r\n  setContext(STICK_TO_BOTTOM_CONTEXT_KEY, context);\r\n  return context;\r\n}\r\n\r\nexport function getStickToBottomContext(): StickToBottomContext {\r\n  const context = getContext<StickToBottomContext>(STICK_TO_BOTTOM_CONTEXT_KEY);\r\n  if (!context) {\r\n    throw new Error(\r\n      \"StickToBottomContext must be used within a Conversation component\"\r\n    );\r\n  }\r\n  return context;\r\n}\r\n\r\nexport { StickToBottomContext };\r\n",
			"type": "registry:file",
			"target": "ai-elements/conversation/stick-to-bottom-context.svelte.ts"
		},
		{
			"content": "export { default as Conversation } from './Conversation.svelte';\r\nexport { default as ConversationContent } from './ConversationContent.svelte';\r\nexport { default as ConversationEmptyState } from './ConversationEmptyState.svelte';\r\nexport { default as ConversationScrollButton } from './ConversationScrollButton.svelte';\r\nexport { getStickToBottomContext, setStickToBottomContext, StickToBottomContext } from './stick-to-bottom-context.svelte.js';\r\n\r\nexport type { ConversationProps } from './Conversation.svelte';\r\nexport type { ConversationContentProps } from './ConversationContent.svelte';\r\nexport type { ConversationEmptyStateProps } from './ConversationEmptyState.svelte';\r\nexport type { ConversationScrollButtonProps } from './ConversationScrollButton.svelte';",
			"type": "registry:file",
			"target": "ai-elements/conversation/index.ts"
		}
	]
}