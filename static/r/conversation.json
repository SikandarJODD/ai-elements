{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "conversation",
	"title": "Conversation",
	"type": "registry:block",
	"author": "SikandarJODD",
	"description": "The Conversation component provides a structured layout for displaying a series of chat messages between a user and an AI. It supports features like message grouping, typing indicators, and customizable avatars.",
	"dependencies": [
		"runed@^0.31.1"
	],
	"devDependencies": [
		"@lucide/svelte@^0.544.0"
	],
	"registryDependencies": [
		"button"
	],
	"meta": {
		"author": "SikandarJODD"
	},
	"files": [
		{
			"content": "<script lang=\"ts\" module>\n\timport { cn, type WithElementRef } from \"$UTILS$\";\n\timport type { HTMLAttributes } from \"svelte/elements\";\n\timport type { Snippet } from \"svelte\";\n\n\texport interface ConversationProps extends WithElementRef<HTMLAttributes<HTMLDivElement>> {\n\t\tchildren?: Snippet;\n\t\tinitial?: ScrollBehavior;\n\t\tresize?: ScrollBehavior;\n\t}\n</script>\n\n<script lang=\"ts\">\n\timport { setStickToBottomContext } from \"./stick-to-bottom-context.svelte.js\";\n\n\tlet {\n\t\tclass: className,\n\t\tchildren,\n\t\tinitial = \"smooth\",\n\t\tresize = \"smooth\",\n\t\tref = $bindable(null),\n\t\t...restProps\n\t}: ConversationProps = $props();\n\n\tlet context = setStickToBottomContext();\n</script>\n\n<div\n\tbind:this={ref}\n\tclass={cn(\"relative flex h-full flex-col overflow-hidden\", className)}\n\trole=\"log\"\n\t{...restProps}\n>\n\t{@render children?.()}\n</div>\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/Conversation.svelte"
		},
		{
			"content": "<script lang=\"ts\" module>\n\timport { cn, type WithElementRef } from \"$UTILS$\";\n\timport type { HTMLAttributes } from \"svelte/elements\";\n\timport type { Snippet } from \"svelte\";\n\n\texport interface ConversationContentProps\n\t\textends WithElementRef<HTMLAttributes<HTMLDivElement>> {\n\t\tchildren?: Snippet;\n\t}\n</script>\n\n<script lang=\"ts\">\n\timport { getStickToBottomContext } from \"./stick-to-bottom-context.svelte.js\";\n\timport { watch } from \"runed\";\n\n\tlet {\n\t\tclass: className,\n\t\tchildren,\n\t\tref = $bindable(null),\n\t\t...restProps\n\t}: ConversationContentProps = $props();\n\n\tconst context = getStickToBottomContext();\n\tlet element: HTMLDivElement;\n\n\twatch(\n\t\t() => element,\n\t\t() => {\n\t\t\tif (element) {\n\t\t\t\tcontext.setElement(element);\n\t\t\t\t// Initial scroll to bottom\n\t\t\t\tcontext.scrollToBottom(\"smooth\");\n\t\t\t}\n\t\t}\n\t);\n</script>\n\n<div\n\tbind:this={element}\n\tbind:this={ref}\n\tclass={cn(\"flex-1 overflow-y-auto p-4\", className)}\n\t{...restProps}\n>\n\t{@render children?.()}\n</div>\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/ConversationContent.svelte"
		},
		{
			"content": "<script lang=\"ts\" module>\n\timport { cn, type WithElementRef } from \"$UTILS$\";\n\timport type { HTMLAttributes } from \"svelte/elements\";\n\timport type { Snippet } from \"svelte\";\n\n\texport interface ConversationEmptyStateProps\n\t\textends WithElementRef<HTMLAttributes<HTMLDivElement>> {\n\t\ttitle?: string;\n\t\tdescription?: string;\n\t\ticon?: Snippet;\n\t\tchildren?: Snippet;\n\t}\n</script>\n\n<script lang=\"ts\">\n\tlet {\n\t\tclass: className,\n\t\ttitle = \"No messages yet\",\n\t\tdescription = \"Start a conversation to see messages here\",\n\t\ticon,\n\t\tchildren,\n\t\tref = $bindable(null),\n\t\t...restProps\n\t}: ConversationEmptyStateProps = $props();\n</script>\n\n<div\n\tbind:this={ref}\n\tclass={cn(\n\t\t\"flex size-full flex-col items-center justify-center gap-3 p-8 text-center\",\n\t\tclassName\n\t)}\n\t{...restProps}\n>\n\t{#if children}\n\t\t{@render children?.()}\n\t{:else}\n\t\t{#if icon}\n\t\t\t<div class=\"text-muted-foreground\">\n\t\t\t\t{@render icon()}\n\t\t\t</div>\n\t\t{/if}\n\t\t<div class=\"space-y-1\">\n\t\t\t<h3 class=\"text-sm font-medium\">{title}</h3>\n\t\t\t{#if description}\n\t\t\t\t<p class=\"text-muted-foreground text-sm\">{description}</p>\n\t\t\t{/if}\n\t\t</div>\n\t{/if}\n</div>\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/ConversationEmptyState.svelte"
		},
		{
			"content": "<script lang=\"ts\" module>\n\timport { cn } from \"$UTILS$\";\n\timport type { ButtonProps } from \"$COMPONENTS$/ui/button/index.js\";\n\n\texport interface ConversationScrollButtonProps extends ButtonProps {}\n</script>\n\n<script lang=\"ts\">\n\timport { Button } from \"$COMPONENTS$/ui/button\";\n\timport { ArrowDown } from \"@lucide/svelte\";\n\timport { getStickToBottomContext } from \"./stick-to-bottom-context.svelte.js\";\n\timport { fade, fly, scale } from \"svelte/transition\";\n\timport { backOut } from \"svelte/easing\";\n\n\tlet { class: className, onclick, ...restProps }: ConversationScrollButtonProps = $props();\n\n\tconst context = getStickToBottomContext();\n\n\tconst handleScrollToBottom = (event: MouseEvent) => {\n\t\tcontext.scrollToBottom();\n\t\tif (onclick) {\n\t\t\tonclick(\n\t\t\t\tevent as MouseEvent & {\n\t\t\t\t\tcurrentTarget: EventTarget & HTMLButtonElement;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t};\n</script>\n\n{#if !context.isAtBottom}\n\t<div\n\t\tin:fly={{\n\t\t\tduration: 300,\n\t\t\ty: 10,\n\t\t\teasing: backOut,\n\t\t}}\n\t\tout:fly={{\n\t\t\tduration: 200,\n\t\t\ty: 10,\n\t\t\teasing: backOut,\n\t\t}}\n\t\tclass=\"absolute bottom-4 left-[50%] translate-x-[-50%]\"\n\t>\n\t\t<Button\n\t\t\tclass={cn(\n\t\t\t\t\"bg-background/80 border-border/50 hover:bg-background/90 rounded-full shadow-lg backdrop-blur-sm hover:shadow-xl\",\n\t\t\t\tclassName\n\t\t\t)}\n\t\t\tonclick={handleScrollToBottom}\n\t\t\tsize=\"icon\"\n\t\t\ttype=\"button\"\n\t\t\tvariant=\"outline\"\n\t\t\t{...restProps}\n\t\t>\n\t\t\t<ArrowDown class=\"size-4\" />\n\t\t</Button>\n\t</div>\n{/if}\n",
			"type": "registry:component",
			"target": "ai-elements/conversation/ConversationScrollButton.svelte"
		},
		{
			"content": "import { watch } from \"runed\";\nimport { setContext, getContext } from \"svelte\";\n\nconst STICK_TO_BOTTOM_CONTEXT_KEY = Symbol(\"stick-to-bottom-context\");\n\nclass StickToBottomContext {\n\t#element: HTMLElement | null = $state(null);\n\t#isAtBottom = $state(true);\n\t#resizeObserver: ResizeObserver | null = null;\n\t#mutationObserver: MutationObserver | null = null;\n\t#intersectionObserver: IntersectionObserver | null = null;\n\t#sentinel: HTMLElement | null = null;\n\t#userHasScrolled = $state(false);\n\n\tisAtBottom = $derived(this.#isAtBottom);\n\n\t// Debug method to help troubleshoot\n\tget debugInfo() {\n\t\tif (!this.#element) return null;\n\t\tconst { scrollTop, scrollHeight, clientHeight } = this.#element;\n\t\treturn {\n\t\t\tscrollTop,\n\t\t\tscrollHeight,\n\t\t\tclientHeight,\n\t\t\tisAtBottom: this.#isAtBottom,\n\t\t\tuserHasScrolled: this.#userHasScrolled,\n\t\t\thasElement: !!this.#element,\n\t\t\thasSentinel: !!this.#sentinel,\n\t\t};\n\t}\n\n\tconstructor() {\n\t\twatch(\n\t\t\t() => this.#element,\n\t\t\t() => {\n\t\t\t\tif (this.#element) {\n\t\t\t\t\tthis.#setupObservers();\n\t\t\t\t\treturn () => this.#cleanup();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tsetElement(element: HTMLElement) {\n\t\tthis.#element = element;\n\t}\n\n\tscrollToBottom = (behavior: ScrollBehavior = \"smooth\") => {\n\t\tif (!this.#element) return;\n\n\t\tthis.#userHasScrolled = false; // Reset user scroll flag when programmatically scrolling\n\t\tthis.#element.scrollTo({\n\t\t\ttop: this.#element.scrollHeight,\n\t\t\tbehavior,\n\t\t});\n\t};\n\n\t#handleScroll = () => {\n\t\tif (!this.#element) return;\n\n\t\t// Detect if user has scrolled up from bottom\n\t\tconst { scrollTop, scrollHeight, clientHeight } = this.#element;\n\t\tconst threshold = 200; // Increased threshold for better UX\n\t\tconst isAtBottom = scrollTop + clientHeight >= scrollHeight - threshold;\n\n\t\t// Update the isAtBottom state based on scroll position\n\t\tthis.#isAtBottom = isAtBottom;\n\n\t\tif (!isAtBottom) {\n\t\t\tthis.#userHasScrolled = true;\n\t\t} else if (isAtBottom && this.#userHasScrolled) {\n\t\t\t// User scrolled back to bottom, reset flag\n\t\t\tthis.#userHasScrolled = false;\n\t\t}\n\t};\n\n\t#setupObservers() {\n\t\tif (!this.#element) return;\n\n\t\t// Create and position sentinel element\n\t\tthis.#createSentinel();\n\n\t\t// Setup intersection observer to detect if we're at bottom\n\t\tthis.#intersectionObserver = new IntersectionObserver(\n\t\t\t(entries) => {\n\t\t\t\tconst entry = entries[0];\n\t\t\t\t// Use intersection observer as a backup, but prioritize scroll-based detection\n\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\tthis.#isAtBottom = true;\n\t\t\t\t\tthis.#userHasScrolled = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tthreshold: 0,\n\t\t\t\troot: this.#element,\n\t\t\t}\n\t\t);\n\n\t\tif (this.#sentinel) {\n\t\t\tthis.#intersectionObserver.observe(this.#sentinel);\n\t\t}\n\n\t\t// Add scroll event listener to detect user scrolling\n\t\tthis.#element.addEventListener(\"scroll\", this.#handleScroll, {\n\t\t\tpassive: true,\n\t\t});\n\n\t\t// Setup resize observer for smooth scrolling on resize\n\t\tthis.#resizeObserver = new ResizeObserver(() => {\n\t\t\t// Check position after resize\n\t\t\tthis.#checkScrollPosition();\n\t\t\tif (this.#isAtBottom && !this.#userHasScrolled) {\n\t\t\t\tthis.scrollToBottom(\"auto\");\n\t\t\t}\n\t\t});\n\n\t\tthis.#resizeObserver.observe(this.#element);\n\n\t\t// Setup mutation observer for smooth scrolling on content changes\n\t\tthis.#mutationObserver = new MutationObserver(() => {\n\t\t\t// Small delay to ensure DOM has updated\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\t// Check if we should auto-scroll BEFORE updating the position\n\t\t\t\t// Only auto-scroll if user was at bottom and hasn't manually scrolled\n\t\t\t\tconst shouldAutoScroll = this.#isAtBottom && !this.#userHasScrolled;\n\n\t\t\t\t// Now update the scroll position after content changes\n\t\t\t\tthis.#checkScrollPosition();\n\n\t\t\t\t// Auto-scroll if conditions were met\n\t\t\t\tif (shouldAutoScroll) {\n\t\t\t\t\tthis.scrollToBottom(\"smooth\");\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tthis.#mutationObserver.observe(this.#element, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tcharacterData: true,\n\t\t});\n\n\t\t// Check initial state\n\t\tthis.#checkScrollPosition();\n\t}\n\n\t#createSentinel() {\n\t\tif (!this.#element) return;\n\n\t\tthis.#sentinel = document.createElement(\"div\");\n\t\tthis.#sentinel.style.height = \"1px\";\n\t\tthis.#sentinel.style.width = \"100%\";\n\t\tthis.#sentinel.style.pointerEvents = \"none\";\n\t\tthis.#sentinel.style.opacity = \"0\";\n\t\tthis.#sentinel.setAttribute(\"data-stick-to-bottom-sentinel\", \"\");\n\n\t\t// Append to the end of the scrollable content, not positioned absolutely\n\t\tthis.#element.appendChild(this.#sentinel);\n\t}\n\n\t#checkScrollPosition() {\n\t\tif (!this.#element) return;\n\n\t\tconst { scrollTop, scrollHeight, clientHeight } = this.#element;\n\t\tconst threshold = 200; // Increased threshold for better UX\n\t\tconst isAtBottom = scrollTop + clientHeight >= scrollHeight - threshold;\n\n\t\tthis.#isAtBottom = isAtBottom;\n\t}\n\n\t#cleanup() {\n\t\tthis.#resizeObserver?.disconnect();\n\t\tthis.#mutationObserver?.disconnect();\n\t\tthis.#intersectionObserver?.disconnect();\n\n\t\t// Remove scroll event listener\n\t\tif (this.#element) {\n\t\t\tthis.#element.removeEventListener(\"scroll\", this.#handleScroll);\n\t\t}\n\n\t\tif (this.#sentinel && this.#element?.contains(this.#sentinel)) {\n\t\t\tthis.#element.removeChild(this.#sentinel);\n\t\t}\n\n\t\tthis.#resizeObserver = null;\n\t\tthis.#mutationObserver = null;\n\t\tthis.#intersectionObserver = null;\n\t\tthis.#sentinel = null;\n\t}\n}\n\nexport function setStickToBottomContext(): StickToBottomContext {\n\tconst context = new StickToBottomContext();\n\tsetContext(STICK_TO_BOTTOM_CONTEXT_KEY, context);\n\treturn context;\n}\n\nexport function getStickToBottomContext(): StickToBottomContext {\n\tconst context = getContext<StickToBottomContext>(STICK_TO_BOTTOM_CONTEXT_KEY);\n\tif (!context) {\n\t\tthrow new Error(\"StickToBottomContext must be used within a Conversation component\");\n\t}\n\treturn context;\n}\n\nexport { StickToBottomContext };\n",
			"type": "registry:file",
			"target": "ai-elements/conversation/stick-to-bottom-context.svelte.ts"
		},
		{
			"content": "export { default as Conversation } from \"./Conversation.svelte\";\nexport { default as ConversationContent } from \"./ConversationContent.svelte\";\nexport { default as ConversationEmptyState } from \"./ConversationEmptyState.svelte\";\nexport { default as ConversationScrollButton } from \"./ConversationScrollButton.svelte\";\nexport {\n\tgetStickToBottomContext,\n\tsetStickToBottomContext,\n\tStickToBottomContext,\n} from \"./stick-to-bottom-context.svelte.js\";\n\nexport type { ConversationProps } from \"./Conversation.svelte\";\nexport type { ConversationContentProps } from \"./ConversationContent.svelte\";\nexport type { ConversationEmptyStateProps } from \"./ConversationEmptyState.svelte\";\nexport type { ConversationScrollButtonProps } from \"./ConversationScrollButton.svelte\";\n",
			"type": "registry:file",
			"target": "ai-elements/conversation/index.ts"
		}
	]
}